在 C++ 中，**构造函数（Constructor）**和**析构函数（Destructor）**是类的两个特殊成员函数，分别用于对象的**初始化**和**清理**。它们在对象的生命周期中自动调用，是面向对象编程的核心机制之一。

---

## **1. 构造函数（Constructor）**
### **定义**
构造函数在创建对象时自动调用，用于初始化对象的成员变量或分配资源。  
- **特点**：
  - 函数名与类名相同。
  - 无返回值（不写 `void` 或返回类型）。
  - 可以重载（多个构造函数，参数不同）。
  - 支持默认参数。

### **语法**
```cpp
class MyClass {
public:
    // 默认构造函数（无参数）
    MyClass() {
        cout << "Default Constructor Called" << endl;
    }

    // 带参数的构造函数
    MyClass(int x, double y) {
        cout << "Parameterized Constructor Called" << endl;
        this->x = x;
        this->y = y;
    }

    // 带默认参数的构造函数
    MyClass(int a = 0) {
        cout << "Constructor with Default Argument" << endl;
    }

private:
    int x;
    double y;
};
```

### **用法**
```cpp
int main() {
    MyClass obj1;          // 调用默认构造函数
    MyClass obj2(10, 3.14); // 调用带参数的构造函数
    MyClass obj3(5);       // 调用带默认参数的构造函数
    return 0;
}
```

### **使用场景**
1. **初始化成员变量**：确保对象创建时成员变量有合理的初始值。
2. **动态内存分配**：在构造函数中申请堆内存（如 `new`）。
3. **资源获取**：打开文件、数据库连接等。

---

## **2. 析构函数（Destructor）**
### **定义**
析构函数在对象销毁时自动调用，用于释放对象占用的资源（如内存、文件句柄等）。  
- **特点**：
  - 函数名是类名前加 `~`。
  - 无参数、无返回值、不能重载（每个类只有一个析构函数）。
  - 如果不定义，编译器会生成默认析构函数（但不会释放动态分配的内存）。

### **语法**
```cpp
class MyClass {
public:
    // 构造函数
    MyClass() {
        data = new int[100]; // 动态分配内存
        cout << "Constructor: Memory Allocated" << endl;
    }

    // 析构函数
    ~MyClass() {
        delete[] data;       // 释放内存
        cout << "Destructor: Memory Freed" << endl;
    }

private:
    int* data;
};
```

### **用法**
```cpp
int main() {
    MyClass obj;  // 构造函数调用
    {
        MyClass tempObj; // 临时对象，作用域结束时析构
    } // tempObj 的析构函数在此调用
    return 0;
} // obj 的析构函数在此调用（main 函数结束时）
```

### **使用场景**
1. **释放动态内存**：避免内存泄漏（如 `delete` 指针）。
2. **关闭资源**：关闭文件、网络连接、数据库连接等。
3. **清理操作**：如写入日志、保存状态等。

---

## **3. 构造函数与析构函数的调用时机**
| **场景**                | **构造函数调用时机**       | **析构函数调用时机**         |
|-------------------------|---------------------------|-----------------------------|
| 局部对象（栈上）         | 定义时（如 `MyClass obj;`） | 作用域结束时                 |
| 动态对象（堆上）         | `new` 时（如 `new MyClass()`） | `delete` 时                 |
| 全局对象                | 程序启动时                | 程序结束时                  |
| 临时对象                | 表达式求值时              | 表达式结束时                |

---

## **4. 特殊构造函数与析构函数**
### **(1) 拷贝构造函数**
用于通过另一个同类对象初始化新对象。
```cpp
class MyClass {
public:
    // 拷贝构造函数
    MyClass(const MyClass& other) {
        this->x = other.x;
        cout << "Copy Constructor Called" << endl;
    }
private:
    int x;
};

int main() {
    MyClass obj1;
    MyClass obj2 = obj1; // 调用拷贝构造函数
    return 0;
}
```

### **(2) 移动构造函数（C++11）**
用于高效转移资源（避免深拷贝）。
```cpp
class MyClass {
public:
    // 移动构造函数
    MyClass(MyClass&& other) noexcept {
        this->data = other.data;
        other.data = nullptr; // 避免原对象析构时释放资源
        cout << "Move Constructor Called" << endl;
    }
private:
    int* data;
};
```

### **(3) 默认与删除的构造函数/析构函数**
- **显式默认**：`MyClass() = default;`
- **禁止使用**：`MyClass() = delete;`

---

## **5. 注意事项**
1. **内存管理**：
   - 如果构造函数中 `new` 了内存，析构函数必须 `delete`。
   - 遵循 **RAII**（资源获取即初始化）原则。
2. **虚析构函数**：
   - 如果类可能被继承，析构函数应声明为 `virtual`，否则通过基类指针删除派生类对象时会导致资源泄漏。
   ```cpp
   class Base {
   public:
       virtual ~Base() { cout << "Base Destructor" << endl; }
   };
   class Derived : public Base {
   public:
       ~Derived() override { cout << "Derived Destructor" << endl; }
   };
   int main() {
       Base* obj = new Derived();
       delete obj; // 正确调用派生类的析构函数
       return 0;
   }
   ```
3. **异常安全**：
   - 构造函数中若抛出异常，析构函数**不会调用**（因为对象未成功创建）。
   - 析构函数通常不应抛出异常（否则可能导致程序终止）。

---

## **6. 完整示例**
```cpp
#include <iostream>
using namespace std;

class FileHandler {
public:
    // 构造函数：打开文件
    FileHandler(const char* filename) {
        file = fopen(filename, "w");
        if (!file) throw runtime_error("Failed to open file");
        cout << "File opened" << endl;
    }

    // 析构函数：关闭文件
    ~FileHandler() {
        if (file) {
            fclose(file);
            cout << "File closed" << endl;
        }
    }

    void write(const char* message) {
        if (file) fprintf(file, "%s\n", message);
    }

private:
    FILE* file;
};

int main() {
    try {
        FileHandler handler("test.txt"); // 构造函数调用
        handler.write("Hello, C++!");
    } catch (const exception& e) {
        cerr << e.what() << endl;
    }
    return 0;
} // handler 的析构函数在此调用（自动关闭文件）
```

---

## **总结**
| **函数**       | **作用**                     | **调用时机**               | **是否可重载** |
|----------------|-----------------------------|---------------------------|----------------|
| 构造函数       | 初始化对象                   | 对象创建时                | 是             |
| 析构函数       | 释放对象资源                 | 对象销毁时                | 否             |
| 拷贝构造函数   | 通过同类对象初始化新对象     | 对象拷贝时（如传值）      | 是             |
| 移动构造函数   | 高效转移资源（C++11）        | 对象移动时（如 `std::move`）| 是             |

掌握构造函数和析构函数是理解 C++ 对象生命周期的关键，合理使用它们可以避免资源泄漏和未定义行为。
